use std::{
    fs::{File, OpenOptions},
    future::Future,
    io::{BufWriter, Write},
    path::Path,
};

use crossbeam::channel::{bounded, Receiver, SendError, Sender, TrySendError};
use fxhash::FxHashMap;
use log::{debug, error};
use samplesheet::{SampleSheetData, SampleSheetSettings};
use thiserror::Error;
use tokio::runtime;

use crate::IlluvatarError;

#[derive(Debug)]
pub struct WriteRecord {
    pub id: String,
    pub reads: String,
    pub qual: String,
    pub destination: String,
}

/// wrap any writer struct into a message-passing interface
///
/// The writer will receive items to write from the recv side of a channel
/// which is generated by [connect](RoutableWrite::connect).
pub(crate) trait RoutableWrite {
    type RouteRecv;
    type RouteSend;

    fn connect(&self, cap: usize) -> Result<(Self::RouteSend, Self::RouteRecv), IlluvatarError>;

    fn write(
        &mut self,
        recv: Self::RouteRecv,
    ) -> impl Future<Output = Result<(), IlluvatarError>> + Send;
}

pub(crate) struct WriteRouter {
    lookup: FxHashMap<String, Sender<WriteRecord>>,
    runtime: runtime::Runtime,
    handles: Vec<tokio::task::JoinHandle<Result<(), IlluvatarError>>>,
    pub write_recv: Receiver<WriteRecord>,
}

/// WriteRouter sends [WriteRecord]s to the appropriate implementor of [RoutableWrite]
///
/// Each installed writer is mapped to a unique ID, and each WriteRecord
/// provides a [destination](WriteRecord::destination) that returns one of these IDs.
impl WriteRouter {
    pub fn new(
        writer_cap: usize,
        max_threads: usize,
    ) -> Result<(WriteRouter, Sender<WriteRecord>), IlluvatarError> {
        let (write_send, write_recv) = bounded(writer_cap);

        let runtime = runtime::Builder::new_multi_thread()
            .worker_threads(max_threads)
            .thread_name("illuvatar-writer")
            .enable_all()
            .build()?;

        Ok((
            WriteRouter {
                runtime,
                handles: Vec::new(),
                lookup: FxHashMap::default(),
                write_recv,
            },
            write_send,
        ))
    }

    /// Given a writer that implements [RoutableWrite], install it into the router
    ///
    /// Each writer is spawned into a multithreaded async runtime.
    pub fn install_writer<
        RW: RoutableWrite<RouteSend = Sender<WriteRecord>, RouteRecv = Receiver<WriteRecord>>
            + Send
            + Sync
            + 'static,
    >(
        &mut self,
        key: String,
        mut writer: RW,
        cap: usize,
    ) -> Result<(), IlluvatarError> {
        let (send, recv) = writer.connect(cap)?;
        self.lookup.insert(key.clone(), send);
        self.handles
            .push(self.runtime.spawn(async move { writer.write(recv).await }));

        Ok(())
    }

    /// Route [WriteRecord] to their corresponding [FastqWriter].
    ///
    /// This blocks to exert backpressure. When the sender is dropped, waits for all writers to
    /// finish writing and then returns.
    pub fn route(&mut self) -> Result<(), RouteError> {
        while let Ok(msg) = self.write_recv.recv() {
            self.route_record(msg)?
        }
        // channel is dead, time to cleanup
        self.lookup.clear(); // trigger writers to finish and flush
        let mut finished = false;
        while !finished {
            finished = self.handles.iter().all(|h| h.is_finished());
        }
        debug!("router is exiting");
        Ok(())
    }

    /// Send a [WriteRecord] to its final destination
    fn route_record(&self, msg: WriteRecord) -> Result<(), RouteError> {
        if let Some(destination) = self.lookup.get(&msg.destination) {
            destination.send(msg)?
        } else {
            return Err(RouteError::UnknownDestination(msg.destination));
        }
        Ok(())
    }
}

#[derive(Debug, Error)]
pub enum RouteError {
    #[error(transparent)]
    SendError(#[from] SendError<WriteRecord>),
    #[error(transparent)]
    TrySendError(#[from] TrySendError<WriteRecord>),
    #[error("attempt to write to unknown destination {0}")]
    UnknownDestination(String),
}

// Initialize file writers for each row of samplesheet data
pub(crate) fn data_to_writers<P: AsRef<Path>>(
    router: &mut WriteRouter,
    data: &[SampleSheetData],
    settings: &SampleSheetSettings,
    output_directory: P,
    writer_cap: usize,
) -> Result<(), IlluvatarError> {
    for sample in data.iter() {
        let r1_path = output_directory
            .as_ref()
            .join(format!("{}_R1.fastq", sample.sample_id));
        let r2_path = output_directory
            .as_ref()
            .join(format!("{}_R2.fastq", sample.sample_id));

        let r1_file = File::create(&r1_path)?;
        let r2_file = File::create(&r2_path)?;

        let r1_writer = FastqWriter {
            inner: BufWriter::new(r1_file),
        };
        let r2_writer = FastqWriter {
            inner: BufWriter::new(r2_file),
        };

        let r1_key = format!("{}_R1", sample.sample_id);
        let r2_key = format!("{}_R2", sample.sample_id);
        router.install_writer(r1_key, r1_writer, writer_cap)?;
        router.install_writer(r2_key, r2_writer, writer_cap)?;

        if settings.create_fastq_for_index_reads {
            let index_path = output_directory
                .as_ref()
                .join(format!("{}_index.fastq", sample.sample_id));
            let index_file = OpenOptions::new().write(true).open(&index_path)?;
            let index_writer = FastqWriter {
                inner: BufWriter::new(index_file),
            };
            let index_key = format!("{}_index", sample.sample_id);
            router.install_writer(index_key, index_writer, writer_cap)?;
        }
    }
    Ok(())
}

// TODO move this elsewhere
pub(crate) struct FastqWriter<W: Write> {
    inner: W,
}

impl FastqWriter<BufWriter<File>> {
    fn new<P: AsRef<Path>>(path: P) -> Result<FastqWriter<BufWriter<File>>, IlluvatarError> {
        let file = File::open(path)?;
        Ok(FastqWriter {
            inner: BufWriter::new(file),
        })
    }

    /// Write a single fastq record to the file
    fn write_record(&mut self, record: WriteRecord) -> Result<(), IlluvatarError> {
        writeln!(self.inner, "{}", record.id)?;
        writeln!(self.inner, "{}", record.reads)?;
        writeln!(self.inner, "+")?;
        writeln!(self.inner, "{}", record.qual)?;
        Ok(())
    }
}

impl RoutableWrite for FastqWriter<BufWriter<File>> {
    type RouteRecv = Receiver<WriteRecord>;
    type RouteSend = Sender<WriteRecord>;

    fn connect(&self, cap: usize) -> Result<(Self::RouteSend, Self::RouteRecv), IlluvatarError> {
        let (send, recv) = bounded(cap);
        Ok((send, recv))
    }

    async fn write(&mut self, recv: Self::RouteRecv) -> Result<(), IlluvatarError> {
        while let Ok(record) = recv.recv() {
            match self.write_record(record) {
                Ok(()) => {}
                Err(e) => {
                    debug!("failed to write record");
                    // we don't flush because it will probably fail
                    // and we want the original error
                    return Err(e);
                }
            }
        }
        // receiver is dead, assume this is fine and flush
        debug!("WRITER EXITING");
        self.inner.flush()?;
        Ok(())
    }
}
